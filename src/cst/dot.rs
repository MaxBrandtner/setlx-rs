/**
 * Generated by ChatGPT
 *
 * TODO implement derive macros to eliminate this boilerplate code
 */
use dot::{GraphWalk, Labeller, LabelText, Id, render};
use std::borrow::Cow;
use setlx_rs::ast::*;
use crate::util::debug_file_create;

// A compact node representation for DOT
#[derive(Clone, Debug)]
enum NodeKind<'a> {
    RootBlock,
    Statement(&'a CSTStatement),
    Expression(&'a CSTExpression),
    Label(String),
}

// Edge with label
#[derive(Clone, Debug)]
struct Edge {
    src: usize,
    dst: usize,
    label: String,
}

// Graph view over a CSTBlock
struct CSTGraph<'a> {
    nodes: Vec<NodeKind<'a>>,
    edges: Vec<Edge>,
}

impl<'a> CSTGraph<'a> {
    fn new(block: &'a CSTBlock) -> Self {
        let mut g = CSTGraph {
            nodes: Vec::new(),
            edges: Vec::new(),
        };
        let root = g.add_node(NodeKind::RootBlock);
        for stmt in block {
            let sid = g.add_node(NodeKind::Statement(stmt));
            g.add_edge(root, sid, "stmt".to_string());
            g.visit_stmt(sid, stmt);
        }
        g
    }

    fn add_node(&mut self, n: NodeKind<'a>) -> usize {
        let id = self.nodes.len();
        self.nodes.push(n);
        id
    }

    fn add_edge(&mut self, src: usize, dst: usize, label: String) {
        self.edges.push(Edge { src, dst, label });
    }

    // ---- Traversal helpers ----

    fn visit_stmt(&mut self, sid: usize, stmt: &'a CSTStatement) {
        use CSTStatement::*;
        match stmt {
            Class(c) => {
                let name = self.add_node(NodeKind::Label(format!("class:{}", c.name)));
                self.add_edge(sid, name, "name".to_string());
                for p in &c.params {
                    self.visit_param(sid, p, "param");
                }
                self.visit_block(sid, &c.block, "block");
                if let Some(b) = &c.static_block {
                    self.visit_block(sid, b, "static");
                }
            }
            If(i) => {
                for (k, br) in i.branches.iter().enumerate() {
                    let bn = self.add_node(NodeKind::Label(format!("if_branch[{k}]")));
                    self.add_edge(sid, bn, "branch".to_string());
                    let cond = self.add_node(NodeKind::Expression(&br.condition));
                    self.add_edge(bn, cond, "cond".to_string());
                    self.visit_expr(cond, &br.condition);
                    self.visit_block(bn, &br.block, "block");
                }
                if let Some(alt) = &i.alternative {
                    self.visit_block(sid, alt, "else");
                }
            }
            Switch(sw) => {
                for (k, case) in sw.cases.iter().enumerate() {
                    let cn = self.add_node(NodeKind::Label(format!("case[{k}]")));
                    self.add_edge(sid, cn, "case".to_string());
                    let cond = self.add_node(NodeKind::Expression(&case.condition));
                    self.add_edge(cn, cond, "cond".to_string());
                    self.visit_expr(cond, &case.condition);
                    self.visit_block(cn, &case.block, "block");
                }
                if let Some(def) = &sw.default {
                    self.visit_block(sid, def, "default");
                }
            }
            Match(m) => {
                let expr = self.add_node(NodeKind::Expression(&m.expression));
                self.add_edge(sid, expr, "match_expr".to_string());
                self.visit_expr(expr, &m.expression);
                for (i, br) in m.branches.iter().enumerate() {
                    match br {
                        CSTMatchBranch::Case(case) => {
                            let bn = self.add_node(NodeKind::Label(format!("case[{i}]")));
                            self.add_edge(sid, bn, "branch".to_string());
                            for e in &case.expressions {
                                let en = self.add_node(NodeKind::Expression(e));
                                self.add_edge(bn, en, "expr".to_string());
                                self.visit_expr(en, e);
                            }
                            if let Some(cond) = &case.condition {
                                let cn = self.add_node(NodeKind::Expression(cond));
                                self.add_edge(bn, cn, "cond".to_string());
                                self.visit_expr(cn, cond);
                            }
                            self.visit_block(bn, &case.statements, "block");
                        }
                        CSTMatchBranch::Regex(rx) => {
                            let bn = self.add_node(NodeKind::Label(format!("regex[{i}]")));
                            self.add_edge(sid, bn, "branch".to_string());
                            let pat = self.add_node(NodeKind::Expression(&rx.pattern));
                            self.add_edge(bn, pat, "pattern".to_string());
                            self.visit_expr(pat, &rx.pattern);
                            if let Some(po) = &rx.pattern_out {
                                let po_n = self.add_node(NodeKind::Expression(po));
                                self.add_edge(bn, po_n, "out".to_string());
                                self.visit_expr(po_n, po);
                            }
                            if let Some(cond) = &rx.condition {
                                let cn = self.add_node(NodeKind::Expression(cond));
                                self.add_edge(bn, cn, "cond".to_string());
                                self.visit_expr(cn, cond);
                            }
                            self.visit_block(bn, &rx.statements, "block");
                        }
                    }
                }
                self.visit_block(sid, &m.default, "default");
            }
            Scan(s) => {
                let expr = self.add_node(NodeKind::Expression(&s.expression));
                self.add_edge(sid, expr, "scan_expr".to_string());
                self.visit_expr(expr, &s.expression);
                if let Some(var) = &s.variable {
                    let vn = self.add_node(NodeKind::Label(format!("var:{var}")));
                    self.add_edge(sid, vn, "variable".to_string());
                }
                for br in &s.branches {
                    if let CSTMatchBranch::Regex(rx) = br {
                        let bn = self.add_node(NodeKind::Label("regex_branch".to_string()));
                        self.add_edge(sid, bn, "branch".to_string());
                        let pat = self.add_node(NodeKind::Expression(&rx.pattern));
                        self.add_edge(bn, pat, "pattern".to_string());
                        self.visit_expr(pat, &rx.pattern);
                        if let Some(po) = &rx.pattern_out {
                            let po_n = self.add_node(NodeKind::Expression(po));
                            self.add_edge(bn, po_n, "out".to_string());
                            self.visit_expr(po_n, po);
                        }
                        if let Some(cond) = &rx.condition {
                            let cn = self.add_node(NodeKind::Expression(cond));
                            self.add_edge(bn, cn, "cond".to_string());
                            self.visit_expr(cn, cond);
                        }
                        self.visit_block(bn, &rx.statements, "block");
                    }
                }
                self.visit_block(sid, &s.default, "default");
            }
            For(f) => {
                for it in &f.params {
                    let pn = self.add_node(NodeKind::Label("iter".to_string()));
                    self.add_edge(sid, pn, "param".to_string());
                    let var = self.add_node(NodeKind::Expression(&it.variable));
                    self.add_edge(pn, var, "var".to_string());
                    self.visit_expr(var, &it.variable);
                    let col = self.add_node(NodeKind::Expression(&it.collection));
                    self.add_edge(pn, col, "in".to_string());
                    self.visit_expr(col, &it.collection);
                }
                if let Some(c) = &f.condition {
                    let cn = self.add_node(NodeKind::Expression(c));
                    self.add_edge(sid, cn, "cond".to_string());
                    self.visit_expr(cn, c);
                }
                self.visit_block(sid, &f.block, "block");
            }
            While(w) | DoWhile(w) => {
                let cn = self.add_node(NodeKind::Expression(&w.condition));
                self.add_edge(sid, cn, "cond".to_string());
                self.visit_expr(cn, &w.condition);
                self.visit_block(sid, &w.block, "block");
            }
            TryCatch(tc) => {
                self.visit_block(sid, &tc.try_branch, "try");
                for c in &tc.catch_branches {
                    let cn = self.add_node(NodeKind::Label(format!("catch:{:?}", c.kind)));
                    self.add_edge(sid, cn, "catch".to_string());
                    let en = self.add_node(NodeKind::Label(c.exception.clone()));
                    self.add_edge(cn, en, "exception".to_string());
                    self.visit_block(cn, &c.block, "block");
                }
            }
            Check(ch) => {
                self.visit_block(sid, &ch.block, "block");
                self.visit_block(sid, &ch.after_backtrack, "after_backtrack");
            }
            Return(r) => {
                if let Some(e) = &r.val {
                    let en = self.add_node(NodeKind::Expression(e));
                    self.add_edge(sid, en, "val".to_string());
                    self.visit_expr(en, e);
                }
            }
            Assign(a) => {
                let an = self.add_node(NodeKind::Expression(&a.assign));
                self.add_edge(sid, an, "lhs".to_string());
                self.visit_expr(an, &a.assign);
                let sn = self.add_node(NodeKind::Statement(&a.expr));
                self.add_edge(sid, sn, "rhs".to_string());
                self.visit_stmt(sn, &a.expr);
            }
            AssignMod(am) => {
                let an = self.add_node(NodeKind::Expression(&am.assign));
                self.add_edge(sid, an, "lhs".to_string());
                self.visit_expr(an, &am.assign);
                let kn = self.add_node(NodeKind::Label(format!("op:{:?}", am.kind)));
                self.add_edge(sid, kn, "op".to_string());
                let rn = self.add_node(NodeKind::Expression(&am.expr));
                self.add_edge(sid, rn, "rhs".to_string());
                self.visit_expr(rn, &am.expr);
            }
            Expression(e) => {
                let en = self.add_node(NodeKind::Expression(e));
                self.add_edge(sid, en, "expr".to_string());
                self.visit_expr(en, e);
            }
            Backtrack | Break | Continue | Exit => {
                // leaf statements
            }
        }
    }

    fn visit_expr(&mut self, eid: usize, expr: &'a CSTExpression) {
        use CSTExpression::*;
        match expr {
            Lambda(l) => {
                let p = self.add_node(NodeKind::Label("params".to_string()));
                self.add_edge(eid, p, "params".to_string());
                self.visit_collection(p, &l.params);
                let clo = self.add_node(NodeKind::Label(format!("closure:{}", l.is_closure)));
                self.add_edge(eid, clo, "is_closure".to_string());
                let body = self.add_node(NodeKind::Expression(&l.expr));
                self.add_edge(eid, body, "body".to_string());
                self.visit_expr(body, &l.expr);
            }
            Op(o) => {
                let opn = self.add_node(NodeKind::Label(format!("op:{:?}", o.op)));
                self.add_edge(eid, opn, "op".to_string());
                let ln = self.add_node(NodeKind::Expression(&o.left));
                self.add_edge(eid, ln, "left".to_string());
                self.visit_expr(ln, &o.left);
                let rn = self.add_node(NodeKind::Expression(&o.right));
                self.add_edge(eid, rn, "right".to_string());
                self.visit_expr(rn, &o.right);
            }
            UnaryOp(u) => {
                let on = self.add_node(NodeKind::Label(format!("unary:{:?}", u.op)));
                self.add_edge(eid, on, "op".to_string());
                let xn = self.add_node(NodeKind::Expression(&u.expr));
                self.add_edge(eid, xn, "expr".to_string());
                self.visit_expr(xn, &u.expr);
            }
            Procedure(p) => {
                let kind = self.add_node(NodeKind::Label(format!("kind:{:?}", p.kind)));
                self.add_edge(eid, kind, "kind".to_string());
                for param in &p.params {
                    self.visit_param(eid, param, "param");
                }
                if let Some(lp) = &p.list_param {
                    let lpn = self.add_node(NodeKind::Label(format!("list_param:{lp}")));
                    self.add_edge(eid, lpn, "list_param".to_string());
                }
                self.visit_block(eid, &p.block, "block");
            }
            Call(c) => {
                let name = self.add_node(NodeKind::Label(format!("call:{}, term:{}", c.name, c.is_term)));
                self.add_edge(eid, name, "name".to_string());
                let curly = self.add_node(NodeKind::Label(format!("curly:{}", c.curly_params)));
                self.add_edge(eid, curly, "curly".to_string());
                for (i, p) in c.params.iter().enumerate() {
                    let pn = self.add_node(NodeKind::Expression(p));
                    self.add_edge(eid, pn, format!("arg[{i}]"));
                    self.visit_expr(pn, p);
                }
                if let Some(rest) = &c.rest_param {
                    let rn = self.add_node(NodeKind::Expression(rest));
                    self.add_edge(eid, rn, "rest".to_string());
                    self.visit_expr(rn, rest);
                }
            }
            Variable(v) => {
                let vn = self.add_node(NodeKind::Label(format!("var:{v}")));
                self.add_edge(eid, vn, "name".to_string());
            }
            Accessible(a) => {
                let hn = self.add_node(NodeKind::Expression(&a.head));
                self.add_edge(eid, hn, "head".to_string());
                self.visit_expr(hn, &a.head);
                for (i, b) in a.body.iter().enumerate() {
                    let bn = self.add_node(NodeKind::Expression(b));
                    self.add_edge(eid, bn, format!("idx[{i}]"));
                    self.visit_expr(bn, b);
                }
            }
            Literal(s) => {
                let ln = self.add_node(NodeKind::Label(format!("lit:{s}")));
                self.add_edge(eid, ln, "literal".to_string());
            }
            Bool(b) => {
                let bn = self.add_node(NodeKind::Label(format!("bool:{b}")));
                self.add_edge(eid, bn, "bool".to_string());
            }
            Double(d) => {
                let dn = self.add_node(NodeKind::Label(format!("double:{d}")));
                self.add_edge(eid, dn, "double".to_string());
            }
            Number(n) => {
                let nn = self.add_node(NodeKind::Label(format!("num:{n}")));
                self.add_edge(eid, nn, "number".to_string());
            }
            Collection(c) => {
                self.visit_collection(eid, c);
            }
            Matrix(rows) => {
                for (i, row) in rows.iter().enumerate() {
                    let rn = self.add_node(NodeKind::Label(format!("row[{i}]")));
                    self.add_edge(eid, rn, "row".to_string());
                    for (j, cell) in row.iter().enumerate() {
                        let cn = self.add_node(NodeKind::Expression(cell));
                        self.add_edge(rn, cn, format!("cell[{j}]"));
                        self.visit_expr(cn, cell);
                    }
                }
            }
            Vector(vs) => {
                for (i, e) in vs.iter().enumerate() {
                    let en = self.add_node(NodeKind::Expression(e));
                    self.add_edge(eid, en, format!("elem[{i}]"));
                    self.visit_expr(en, e);
                }
            }
            Quantifier(q) => {
                let kn = self.add_node(NodeKind::Label(format!("quant:{:?}", q.kind)));
                self.add_edge(eid, kn, "kind".to_string());
                for it in &q.iterators {
                    let inod = self.add_node(NodeKind::Label("iter".to_string()));
                    self.add_edge(eid, inod, "iter".to_string());
                    let var = self.add_node(NodeKind::Expression(&it.variable));
                    self.add_edge(inod, var, "var".to_string());
                    self.visit_expr(var, &it.variable);
                    let col = self.add_node(NodeKind::Expression(&it.collection));
                    self.add_edge(inod, col, "in".to_string());
                    self.visit_expr(col, &it.collection);
                }
                let cond = self.add_node(NodeKind::Expression(&q.condition));
                self.add_edge(eid, cond, "cond".to_string());
                self.visit_expr(cond, &q.condition);
            }
            Om | Ignore => {
                let nm = self.add_node(NodeKind::Label(match expr {
                    Om => "om".to_string(),
                    Ignore => "ignore".to_string(),
                    _ => unreachable!(),
                }));
                self.add_edge(eid, nm, "marker".to_string());
            }
        }
    }

    fn visit_block(&mut self, parent: usize, block: &'a CSTBlock, label: &str) {
        let bn = self.add_node(NodeKind::Label(format!("block(len={})", block.len())));
        self.add_edge(parent, bn, label.to_string());
        for stmt in block {
            let sid = self.add_node(NodeKind::Statement(stmt));
            self.add_edge(bn, sid, "stmt".to_string());
            self.visit_stmt(sid, stmt);
        }
    }

    fn visit_param(&mut self, parent: usize, p: &'a CSTParam, label: &str) {
        let pn = self.add_node(NodeKind::Label(format!("param:{} rw:{}", p.name, p.is_rw)));
        self.add_edge(parent, pn, label.to_string());
        if let Some(def) = &p.default {
            let dn = self.add_node(NodeKind::Expression(def));
            self.add_edge(pn, dn, "default".to_string());
            self.visit_expr(dn, def);
        }
    }

    fn visit_collection(&mut self, parent: usize, c: &'a CSTCollection) {
        match c {
            CSTCollection::Set(s) | CSTCollection::List(s) => {
                if let Some(r) = &s.range {
                    let rn = self.add_node(NodeKind::Label("range".to_string()));
                    self.add_edge(parent, rn, "range".to_string());
                    if let Some(l) = &r.left {
                        let ln = self.add_node(NodeKind::Expression(l));
                        self.add_edge(rn, ln, "left".to_string());
                        self.visit_expr(ln, l);
                    }
                    if let Some(rg) = &r.right {
                        let rn2 = self.add_node(NodeKind::Expression(rg));
                        self.add_edge(rn, rn2, "right".to_string());
                        self.visit_expr(rn2, rg);
                    }
                }
                for (i, e) in s.expressions.iter().enumerate() {
                    let en = self.add_node(NodeKind::Expression(e));
                    self.add_edge(parent, en, format!("elem[{i}]"));
                    self.visit_expr(en, e);
                }
            }
            CSTCollection::SetComprehension(comp) | CSTCollection::ListComprehension(comp) => {
                let cn = self.add_node(NodeKind::Label("comprehension".to_string()));
                self.add_edge(parent, cn, "comp".to_string());
                for (i, e) in comp.expressions.iter().enumerate() {
                    let en = self.add_node(NodeKind::Expression(e));
                    self.add_edge(cn, en, format!("expr[{i}]"));
                    self.visit_expr(en, e);
                }
                for it in &comp.iterators {
                    let inod = self.add_node(NodeKind::Label("iter".to_string()));
                    self.add_edge(cn, inod, "iter".to_string());
                    let var = self.add_node(NodeKind::Expression(&it.variable));
                    self.add_edge(inod, var, "var".to_string());
                    self.visit_expr(var, &it.variable);
                    let col = self.add_node(NodeKind::Expression(&it.collection));
                    self.add_edge(inod, col, "in".to_string());
                    self.visit_expr(col, &it.collection);
                }
                if let Some(cond) = &comp.condition {
                    let condn = self.add_node(NodeKind::Expression(cond));
                    self.add_edge(cn, condn, "cond".to_string());
                    self.visit_expr(condn, cond);
                }
            }
        }
    }
}

// ---- dot::GraphWalk + dot::Labeller implementations ----

impl<'a> GraphWalk<'a, usize, (usize, usize)> for CSTGraph<'a> {
    fn nodes(&'a self) -> dot::Nodes<'a, usize> {
        (0..self.nodes.len()).collect()
    }

    fn edges(&'a self) -> dot::Edges<'a, (usize, usize)> {
        self.edges.iter().map(|e| (e.src, e.dst)).collect()
    }

    fn source(&self, e: &(usize, usize)) -> usize { e.0 }
    fn target(&self, e: &(usize, usize)) -> usize { e.1 }
}

impl<'a> Labeller<'a, usize, (usize, usize)> for CSTGraph<'a> {
    fn graph_id(&self) -> Id<'a> {
        Id::new("cst").unwrap()
    }

    fn node_id(&self, n: &usize) -> Id<'a> {
        Id::new(format!("n{n}")).unwrap()
    }

    fn node_label(&self, n: &usize) -> LabelText<'a> {
        match &self.nodes[*n] {
            NodeKind::RootBlock => LabelText::LabelStr(Cow::Borrowed("RootBlock")),
            NodeKind::Statement(s) => LabelText::LabelStr(Cow::Owned(format!("Stmt:{}", stmt_name(s)))),
            NodeKind::Expression(e) => LabelText::LabelStr(Cow::Owned(format!("Expr:{}", expr_name(e)))),
            NodeKind::Label(s) => LabelText::LabelStr(Cow::Owned(s.clone())),
        }
    }

    fn edge_label(&self, e: &(usize, usize)) -> LabelText<'a> {
        if let Some(found) = self.edges.iter().find(|x| x.src == e.0 && x.dst == e.1) {
            LabelText::LabelStr(Cow::Owned(found.label.clone()))
        } else {
            LabelText::LabelStr(Cow::Borrowed(""))
        }
    }
}

// ---- Helpers to print variant names cleanly ----

fn stmt_name(s: &CSTStatement) -> &'static str {
    use CSTStatement::*;
    match s {
        Class(_) => "Class",
        If(_) => "If",
        Switch(_) => "Switch",
        Match(_) => "Match",
        Scan(_) => "Scan",
        For(_) => "For",
        While(_) => "While",
        DoWhile(_) => "DoWhile",
        TryCatch(_) => "TryCatch",
        Check(_) => "Check",
        Return(_) => "Return",
        Assign(_) => "Assign",
        AssignMod(_) => "AssignMod",
        Expression(_) => "Expression",
        Backtrack => "Backtrack",
        Break => "Break",
        Continue => "Continue",
        Exit => "Exit",
    }
}

fn expr_name(e: &CSTExpression) -> &'static str {
    use CSTExpression::*;
    match e {
        Lambda(_) => "Lambda",
        Op(_) => "Op",
        UnaryOp(_) => "UnaryOp",
        Procedure(_) => "Procedure",
        Call(_) => "Call",
        Variable(_) => "Variable",
        Accessible(_) => "Accessible",
        Literal(_) => "Literal",
        Bool(_) => "Bool",
        Double(_) => "Double",
        Number(_) => "Number",
        Collection(_) => "Collection",
        Matrix(_) => "Matrix",
        Vector(_) => "Vector",
        Quantifier(_) => "Quantifier",
        Om => "Om",
        Ignore => "Ignore",
    }
}

pub fn cst_dump_dot(cst: &CSTBlock, stem: &str) {
    let graph = CSTGraph::new(cst);

    let mut file = debug_file_create(format!("{stem}-cst-tree.dot"));
    render(&graph, &mut file).unwrap();
}
